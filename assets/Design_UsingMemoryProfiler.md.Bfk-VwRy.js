import{_ as s,c as a,o as i,a4 as l}from"./chunks/framework.Br2U662V.js";const n="/minigame-unity-webgl-transform/assets/memoryprofiler1.DqqM3hJv.png",e="/minigame-unity-webgl-transform/assets/memoryprofiler2.CO1KsCPI.png",t="/minigame-unity-webgl-transform/assets/memoryprofiler3.BHNFw8hn.png",p="/minigame-unity-webgl-transform/assets/memoryprofiler4.fmpW3n4Z.png",o="/minigame-unity-webgl-transform/assets/memoryprofiler5.BQ-2xA41.png",_=JSON.parse('{"title":"使用ProfilingMemory内存分析","description":"","frontmatter":{},"headers":[],"relativePath":"Design/UsingMemoryProfiler.md","filePath":"Design/UsingMemoryProfiler.md"}'),r={name:"Design/UsingMemoryProfiler.md"},h=l('<h1 id="使用profilingmemory内存分析" tabindex="-1">使用ProfilingMemory内存分析 <a class="header-anchor" href="#使用profilingmemory内存分析" aria-label="Permalink to &quot;使用ProfilingMemory内存分析&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>在微信开发者工具运行游戏，利用ProfilingMemory，我们可以分析UnityHeap 或 DynamicMemory(CPU主内存)的详细分配堆栈与统计数值。</p><ul><li>该工具仅分析业务与引擎的CPU内存，即性能面板中的DynamicMemory中可被追踪到的内存情况，不包含WASM编译内存、显存、JS临时内存等</li><li>建议在微信开发者工具 or Android使用（工具本身会增加不少内存，此时iOS WebContent进程内存压力会很大）</li><li>当进行了Lua内存分配器替换操作后（参考常见问题 1），Profiling Memory将无法统计到Lua的内存分配。</li><li>Profiling Memory无法统计到Mono相关的内存。</li></ul><h2 id="步骤" tabindex="-1">步骤 <a class="header-anchor" href="#步骤" aria-label="Permalink to &quot;步骤&quot;">​</a></h2><ol><li><p>游戏启动调用WeChatWASM.WX.InitSDK，并勾选导出选项&quot;Profiling Funcs&quot;与&quot;Profiling Memory&quot;，<em><strong>请勿同时勾选&quot;Development Build&quot;选项！！！</strong></em><img src="'+n+'" width="800"></p></li><li><p>在微信开发者工具运行游戏，过程中会自动记录所有内存分配数据</p></li><li><p>导出内存堆栈数据</p></li></ol><ul><li>方式1：点击性能面板左上角的&quot;ProfilingMemory Dump&quot; 完成导出（开启性能面板可通过修改unity-namespace.js-enableProfileStats或C#调用OpenProfileStats）</li><li>方式2：在微信开发者工具中选择gameContext, 并在Console输入命令: GameGlobal.memprofiler.onDump()。 <img src="'+e+'" width="600"></li></ul><ol start="4"><li><p>微信开发者工具-“游戏缓存目录/usr/alloc_used.csv”（Android位于data/com.tencent.mm/MicroMsg/wxanewfiles/最近使用时间的目录）拖拽并以csv方式导入sqlite数据库， 推荐使用<a href="https://sqlitebrowser.org/" target="_blank" rel="noreferrer">DB Browser for SQLite</a></p><img src="'+t+'" width="600"><img src="'+p+'" width="400"></li><li><p>对表格执行格式化换行 update alloc_used set callback=replace(callback, &#39;at &#39;, x&#39;0a&#39;)</p></li></ol><h2 id="数据分析" tabindex="-1">数据分析 <a class="header-anchor" href="#数据分析" aria-label="Permalink to &quot;数据分析&quot;">​</a></h2><h3 id="浏览数据" tabindex="-1">浏览数据 <a class="header-anchor" href="#浏览数据" aria-label="Permalink to &quot;浏览数据&quot;">​</a></h3><p>典型地，我们可以通过size进行排序分析内存最大占用的堆栈情况 <img src="'+o+`" width="800"></p><p>其中：</p><ul><li>callback: 堆栈</li><li>count: 当前存活的分配次数</li><li>size: 当前使用内存</li><li>malloc: 总分配次数</li><li>free: 总释放次数</li></ul><h3 id="sql统计分析" tabindex="-1">SQL统计分析 <a class="header-anchor" href="#sql统计分析" aria-label="Permalink to &quot;SQL统计分析&quot;">​</a></h3><p>我们可以在&quot;执行SQL&quot;窗口使用SQL进行数据统计和分析，常见的callback分配堆栈特征：</p><p>Unity 2021:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span> 所有内存： select sum(size) from alloc_used</span></span>
<span class="line"><span></span></span>
<span class="line"><span> AssetBundle Storage Memory: select sum(size) from alloc_used where callback like &quot;%AssetBundle_LoadFromMemory%&quot; or callback like &quot;%OnFinishReceiveData%&quot; or callback like &quot;%AssetBundleLoadFromStream%&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span> AssetBundle Info:  select sum(size) from alloc_used where callback like &quot;%get_assetBundle%&quot; and callback not like &quot;%AwakeFromLoad%&quot;</span></span>
<span class="line"><span> </span></span>
<span class="line"><span> AssetBundle TypeTree: select sum(size) from alloc_used where callback like &quot;%TypeTree%&quot; </span></span>
<span class="line"><span></span></span>
<span class="line"><span> Lua: select sum(size) from alloc_used where callback like &quot;%luaY_parser%&quot; or callback like &quot;%luaH_resize%&quot; or callback like &quot;%luaM_realloc%&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> Shader: select sum(size) from alloc_used where callback like &quot;%ShaderLab%&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> IL2CPP runtime: select sum(size) from alloc_used where callback like &quot;%MetadataCache%&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 非压缩纹理软解: select sum(size) from alloc_used where callback like &quot;%Mipmap%&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Other： select sum(size) from alloc_used where callback not like &quot;%xxx%&quot; or callback not like &quot;%xxx%&quot;</span></span></code></pre></div><p>Unity 2018~2020：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>AssetBundle Storage Memory: select sum(size) from alloc_used where callback like &quot;%AssetBundleLoadFromStreamAsyncOperation%&quot; </span></span>
<span class="line"><span></span></span>
<span class="line"><span>AssetBundle Info: select sum(size) from alloc_used where callback like &quot;%get_assetBundle%&quot; and callback not like &quot;%AwakeFromLoad%&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>AssetBundle TypeTree: select sum(size) from alloc_used where callback like &quot;%TypeTree%&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Lua： select sum(size) from alloc_used where callback like &quot;%luaY_parser%&quot; or callback like &quot;%luaH_resize%&quot; or callback like &quot;%luaM_realloc%&quot; </span></span>
<span class="line"><span></span></span>
<span class="line"><span>Shader: select sum(size) from alloc_used where callback like &quot;%ShaderFromSerializedShader%&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>IL2CPP runtime: select sum(size) from alloc_used where callback like &quot;%MetadataCache%&quot; -19M</span></span>
<span class="line"><span></span></span>
<span class="line"><span>动画数据： select  sum(size) from alloc_used where callback like &quot;%AnimationClip%&quot; -7MB</span></span>
<span class="line"><span></span></span>
<span class="line"><span>非压缩纹理软解: select sum(size) from alloc_used where callback like &quot;%Mipmap%&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Other： select sum(size) from alloc_used where callback not like &quot;%xxx%&quot; or callback not like &quot;%xxx%&quot;</span></span></code></pre></div><p>除了常见的堆栈特征外，我们也可以根据业务自己的使用特点来进行SQL分析。</p><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><h3 id="_1-开启proflingmemory后非常慢-特别是在有lua逻辑的情况" tabindex="-1">1. 开启ProflingMemory后非常慢，特别是在有Lua逻辑的情况 <a class="header-anchor" href="#_1-开启proflingmemory后非常慢-特别是在有lua逻辑的情况" aria-label="Permalink to &quot;1. 开启ProflingMemory后非常慢，特别是在有Lua逻辑的情况&quot;">​</a></h3><ul><li>首先，这是正常情况，因为每次分配内存都会获取堆栈信息导致运行慢</li><li>Lua会存在大量分配行为，会加重这个问题， 因此我们提供了专门的内存分配器忽略Lua内存，具体做法：</li></ul><ol><li>将<a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/tools/simpledlmalloc.c" target="_blank" rel="noreferrer">simpledlmalloc.c</a>添加到xLua虚拟机源码目录下参与编译，（和lauxlib.c同一目录）</li><li>参考<a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/tools/lauxlib.c" target="_blank" rel="noreferrer">lauxlib.c</a>，在lua源码目录下的同名文件中增加<code>simple_dlmalloc</code>，并修改<code>LUALIB_API lua_State *luaL_newstate (void)</code> 为如下所示<div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;simpledlmalloc.c&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">simple_dlmalloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ud</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> osize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> nsize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)ud; (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)osize;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* not used */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nsize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         dlfree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ptr);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dlrealloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ptr, nsize);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // using other_alloc instead of default dlmalloc to avoid print trace of lua</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LUALIB_API lua_State </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">luaL_newstate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // lua_State *L = lua_newstate(l_alloc, NULL);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     lua_State </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">L </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lua_newstate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(simple_dlmalloc, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (L) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lua_atpanic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">panic);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> L;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li></ol><h3 id="_2-profilingmemory在真机上更容易出现内存崩溃" tabindex="-1">2. ProfilingMemory在真机上更容易出现内存崩溃 <a class="header-anchor" href="#_2-profilingmemory在真机上更容易出现内存崩溃" aria-label="Permalink to &quot;2. ProfilingMemory在真机上更容易出现内存崩溃&quot;">​</a></h3><ul><li>ProfilingMemory功能需要额外的内存记录堆栈与相关统计，因此JS侧内存压力会更大</li><li>理论上UnityHeap(CPU主内存)在不同端上的行为基本是一致的，由于iOS内存更苛刻，建议使用微信开发者工具或Android真机进行内存堆栈导出</li></ul>`,26),k=[h];function c(u,d,m,g,y,E){return i(),a("div",null,k)}const q=s(r,[["render",c]]);export{_ as __pageData,q as default};
