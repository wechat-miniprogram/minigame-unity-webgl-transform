import{_ as e,c as t,o as a,a4 as i}from"./chunks/framework.Br2U662V.js";const o="/minigame-unity-webgl-transform/assets/ParticleSystem%20Update.Dd4t_Fgx.png",r="/minigame-unity-webgl-transform/assets/ParticleSystemBudgetWorkflow.ak2SqPoG.png",l="/minigame-unity-webgl-transform/assets/ParticleSystemController.B0SXoGeI.png",c="/minigame-unity-webgl-transform/assets/ParticleSystemBudget.BnhDyesy.png",d="/minigame-unity-webgl-transform/assets/Performance_Data.CVmklKv2.png",b=JSON.parse('{"title":"性能优化实战——使用Particle Budget系统优化粒子性能","description":"","frontmatter":{},"headers":[],"relativePath":"Design/ParticleBudget.md","filePath":"Design/ParticleBudget.md"}'),n={name:"Design/ParticleBudget.md"},s=i('<h1 id="性能优化实战——使用particle-budget系统优化粒子性能" tabindex="-1">性能优化实战——使用Particle Budget系统优化粒子性能 <a class="header-anchor" href="#性能优化实战——使用particle-budget系统优化粒子性能" aria-label="Permalink to &quot;性能优化实战——使用Particle Budget系统优化粒子性能&quot;">​</a></h1><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>在Unity的游戏项目中，针对粒子较多的场景，往往粒子的更新会占用比较高的开销：</p><p><img src="'+o+'" alt="Particle Update"></p><p>粒子的性能优化一直困扰开发者——如何在粒子的性能、表现和管理成本之间达到平衡？</p><p>本文介绍一种高级优化方案：<code>Particle Update Budget</code>。通过限制每帧的粒子模拟预算，从而得以在粒子的性能和表现之间达到平衡。此外，该方案涉及的需要配置的参数也较少，也意味着较低的管理成本。</p><h2 id="原理介绍" tabindex="-1">原理介绍 <a class="header-anchor" href="#原理介绍" aria-label="Permalink to &quot;原理介绍&quot;">​</a></h2><h3 id="核心理念" tabindex="-1">核心理念 <a class="header-anchor" href="#核心理念" aria-label="Permalink to &quot;核心理念&quot;">​</a></h3><p>本方案的核心组件为<code>ParticleSimulationBudget</code>和<code>ParticleSystemController</code>。是针对每个Particle System，根据其优先级手动进行<code>Particle.Simulate</code>方法的调用。</p><ul><li><code>ParticleSystemController</code>：管理某个Particle System，负责设定该Particle System的优先级相关参数，将其注册到<code>ParticleSimulationBudget</code>，以及计算该Particle System的优先级。</li><li><code>ParticleSimulationBudget</code>：单例管理类，维护两个粒子数组：每帧强制更新的<code>ForceUpdate</code>粒子与根据优先级按需更新的<code>Managed</code>数组。针对<code>Managed</code>数组，系统会根据时间预算进行<code>Particle.Simulate</code>方法的手动调用。</li></ul><p>流程图如下：</p><p><img src="'+r+'" alt="流程图"></p><p>该方案的优点如下：</p><ol><li><strong>平衡性能与表现</strong>：在CPU负载较高时，可以保证帧率；而在CPU负载较低时，可以保证效果。相比起强制降帧方案，对表现更加友好。</li><li><strong>负载可控</strong>：可以确保粒子的模拟模块开销不高于一个最高值，助于帧率的稳定。</li><li><strong>管理成本低</strong>：针对高、中、低配平台，只需要进行预算值的配置即可。</li></ol><h3 id="粒子优先级的计算" tabindex="-1">粒子优先级的计算 <a class="header-anchor" href="#粒子优先级的计算" aria-label="Permalink to &quot;粒子优先级的计算&quot;">​</a></h3><p>粒子的优先级决定了这一帧该粒子是否需要更新，优先级的计算考虑如下因素：</p><ol><li>该粒子的基准优先级预设类别：被标记为<code>High Priority</code>的粒子比<code>Normal</code>的粒子优先级更高</li><li>距离上一次该粒子更新的时间间隔：该粒子越久没有更新，则优先级越高</li><li>该粒子与相机的距离：如果该粒子离相机越近，则优先级越高</li></ol><p>各因素之间通过数值关系组合，最终获得该粒子在这一帧的更新优先级。</p><p>具体的公式可以查看Demo工程中的<code>ParticleSystemController.CalculatePriority</code>方法。当然，读者也可以根据自己的需求自定义公式。</p><p>注：理论上屏占比比距离是一个更加合理的因素，但是屏占比的计算需要进行两次矩阵的计算，对性能反而有负面的影响。</p><h3 id="组件细节" tabindex="-1">组件细节 <a class="header-anchor" href="#组件细节" aria-label="Permalink to &quot;组件细节&quot;">​</a></h3><ul><li><p><code>ParticleSystemController</code>组件 该组件与<code>Particle System</code>挂载在同一个GameObject下： <img src="'+l+'" alt="Particle System Controller"><code>Priority Preset</code>可选：<code>Force Update</code>（强制更新）、<code>High Priority</code>（高优先级）、<code>Normal</code>(正常优先级)。</p></li><li><p><code>ParticleSimulationBudgetManager</code>组件 该组件为一个全局单例： <img src="'+c+'" alt="ParticleSimulationBudgetManager"> 可以在这个组件中通过<code>Max Frame Budget MS</code>属性进行预算的设置（以毫秒为单位）。</p></li></ul><h2 id="性能数据" tabindex="-1">性能数据 <a class="header-anchor" href="#性能数据" aria-label="Permalink to &quot;性能数据&quot;">​</a></h2><p>我们在场景中放置了101个粒子特效，其中4个粒子被设置为<code>Force Update</code>、34个粒子被设置为<code>High Priority</code>、剩下的被设置为<code>Normal</code>。</p><p>默认我们将所有的<code>Particle System Controller</code>组件的Enable设为False，并且模拟20s，让每个粒子的数量都膨胀到一定数量后，开启CPU Profiler。</p><p>我们使用的测试设备为Mi 8 UD，Budget设为2ms每帧，结果如下：</p><p><img src="'+d+'" alt="Perf Data"></p><p>可以看到，Budget方案下，<code>ParticleSimulationBudgetManager.LateUpdate</code>函数开销略高于2ms。而原方案下，所有的粒子都会进行模拟操作，开销为3.43ms，且不可控。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>本文介绍的Particle Budget系统提供了一种有效的Unity粒子性能优化方案，主要特点和优势包括：</p><ol><li><p><strong>核心机制</strong>：</p><ul><li>通过ParticleSystemController和ParticleSimulationBudgetManager两个核心组件实现</li><li>采用优先级调度机制，综合考虑预设优先级、更新间隔和相机距离等因素</li></ul></li><li><p><strong>主要优势</strong>：</p><ul><li>性能与表现的平衡：在保证帧率的同时尽可能维持粒子效果</li><li>负载可控：确保粒子模拟开销不超过预设预算值</li><li>管理简便：只需配置预算值和优先级预设，无需复杂调优</li></ul></li><li><p><strong>应用建议</strong>：</p><ul><li>适用于粒子密集的场景，特别是移动端性能敏感项目</li><li>可根据目标平台性能调整预算值(高配平台可适当增加预算)</li><li>对关键特效使用Force Update，次要特效使用优先级管理</li></ul></li></ol><p>可以参考<a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/tree/main/Demo/particlebudget" target="_blank" rel="noreferrer">Demo</a>，开发者可根据项目需求灵活调整优先级计算策略和预算值。</p>',32),m=[s];function p(g,u,P,h,_,S){return a(),t("div",null,m)}const f=e(n,[["render",p]]);export{b as __pageData,f as default};
