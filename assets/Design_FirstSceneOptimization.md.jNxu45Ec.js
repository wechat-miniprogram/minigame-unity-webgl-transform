import{_ as t,E as e,c as n,m as l,a as i,J as r,w as o,a4 as s,o as p}from"./chunks/framework.Br2U662V.js";const h="/minigame-unity-webgl-transform/assets/profile.yCnwPQ6L.png",d="/minigame-unity-webgl-transform/assets/stop.CFvG6dL8.png",k="/minigame-unity-webgl-transform/assets/stopprofile.DmPV0U4-.png",g="/minigame-unity-webgl-transform/assets/chromeload.sYqunEFg.png",c="/minigame-unity-webgl-transform/assets/benchmarkprofile.BvHHzfgK.png",v=JSON.parse('{"title":"首场景启动优化","description":"","frontmatter":{},"headers":[],"relativePath":"Design/FirstSceneOptimization.md","filePath":"Design/FirstSceneOptimization.md"}'),m={name:"Design/FirstSceneOptimization.md"},E=s('<h1 id="首场景启动优化" tabindex="-1">首场景启动优化 <a class="header-anchor" href="#首场景启动优化" aria-label="Permalink to &quot;首场景启动优化&quot;">​</a></h1><p>在<a href="./StartupOptimization.html">提升Unity WebGL游戏启动速度</a>章节我们提到过：</p><blockquote><p>在timelog中呈现的首场景耗时即为引擎初始化与开发者首帧逻辑，关于该阶段耗时，开发者需要注意的是：</p><ol><li>MonoBehaviour脚本的首帧Start/Awake应足够少逻辑，优先将画面呈现</li><li>初始场景不宜过大，通常呈现Splash场景即可</li><li>初始场景中需要后续主场景或配置加载时可采取分帧策略，切勿在Start/Awake阻塞</li></ol></blockquote><p>下面介绍如何通过在小游戏下通过Profile的方式对小游戏首场景耗时进行针对性优化。</p><h2 id="小游戏profile" tabindex="-1">小游戏Profile <a class="header-anchor" href="#小游戏profile" aria-label="Permalink to &quot;小游戏Profile&quot;">​</a></h2><p>微信小游戏在安卓平台提供了CPU Profile能力，使用姿势为： 1.采集Profile： 点击右上角菜单 -&gt; 开发调试 -&gt; Start CPU Profile -&gt; Stop CPU Profile； <img src="'+h+'" width="300"> <img src="'+d+'" width="300"> <img src="'+k+'" width="300"> 2.导出Profile文件 当点击Stop CPU Profile之后，会弹出浮窗告知profile文件的存储路径，通过USB链接电脑或者第三方文件管理器即可将Profile文件传输至电脑。</p><p>3.Chrome导入Profile文件 打开Chrome浏览器，右键审查元素或者按F12即可打开控制台界面。选中JavaScript Profile tab(如果默认没有，可能在右上角的三个点展开菜单-&gt;More tools里面)，点击load导入步骤2的profile文件，Profile文件的使用可以参考Google的开发文档: <a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution" target="_blank" rel="noreferrer">https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution</a><img src="'+g+'" width="900"></p><h2 id="unity-callmain" tabindex="-1">Unity CallMain <a class="header-anchor" href="#unity-callmain" aria-label="Permalink to &quot;Unity CallMain&quot;">​</a></h2><p>参考文档<a href="./Startup.html">小游戏启动流程</a>中提到的，当游戏代码包下载编译完成和首包资源下载完成后会运行游戏逻辑，最开始执行的逻辑是CallMain主函数。 在WebGL模式下，CallMain的主要是initWebGLPlayer调用，主要分成两部分调用：</p><ul><li>Unity引擎初始化：主要分成：InitializeIl2CppFromMain、RuntimeInitialize、PlayerInitEngineNoGraphics和PlayerInitEngineGraphics等函数调用；</li><li>首场景初始化：PlayerLoadFirstScene函数调用；</li></ul><p>下表为针对Unity Benchmark项目在不同设备上的callmain耗时分析，Benchmark项目链接：<a href="https://github.com/Unity-Technologies/Benchmark" target="_blank" rel="noreferrer">https://github.com/Unity-Technologies/Benchmark</a></p><blockquote><p>下面实验均采用Unity 2018.4.24f1版本，Development模式会对性能有一定影响，下表数据均为Development模式下数据。</p></blockquote><table><thead><tr><th>initWebGLPlayer主要函数</th><th>安卓魅族6s</th><th>OPPO A37m</th><th>安卓小米10</th><th>开发者工具</th></tr></thead><tbody><tr><td>InitializeIl2CppFromMain</td><td>525ms</td><td>954ms</td><td>113ms</td><td>39.90ms</td></tr><tr><td>RuntimeInitialize</td><td>139ms</td><td>649ms</td><td>50.2ms</td><td>2.33ms</td></tr><tr><td>PlayerInitEngineNoGraphics</td><td>463.8ms</td><td>1.24s</td><td>154ms</td><td>10.46ms</td></tr><tr><td>PlayerInitEngineGraphics</td><td>1.4s</td><td>2.94s</td><td>403ms</td><td>126ms</td></tr><tr><td>PlayerLoadFirstScene</td><td><strong>815ms</strong></td><td><strong>2.12s</strong></td><td><strong>213ms</strong></td><td><strong>70.75ms</strong></td></tr></tbody></table>',13),y=s(`<h2 id="callmain-profile分析" tabindex="-1">CallMain Profile分析 <a class="header-anchor" href="#callmain-profile分析" aria-label="Permalink to &quot;CallMain Profile分析&quot;">​</a></h2><p>1.改造小游戏代码 因为安卓采集Profile文件需要手动控制，而CallMain会在码包下载编译完成和首包资源下载完成后就执行，为了录制启动阶段完整的Profile，需要保证Profile的录制开始之后才真正执行游戏开始逻辑，找到项目的game.js文件，做如下改造：</p><ul><li>搜索<code>loadingPageConfig</code>字段，添加<code>visible: false</code>字段，如下：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hideAfterCallmain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        loadingPageConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            visible</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 以下是默认值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            totalLaunchTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            animationDuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span></code></pre></div><ul><li>搜索<code>gameManager.startGame()</code>字段，将其放入wx.onTouchStart事件中，如下：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// gameManager.startGame();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">wx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onTouchStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;真正执行开始游戏逻辑&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  gameManager.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startGame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GameGlobal.manager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gameManager;</span></span></code></pre></div><p>通过上面的改造，在进入小游戏后，可以按照这个流程采集Profile：Start CPU Profile -&gt; 点击屏幕触发真正的开始游戏逻辑 -&gt; 看到游戏界面后Stop Profile。</p><p>2.导入步骤1的启动过程Profile文件 <img src="`+c+'" width="900"></p><p>导入文件后，我们只需要关注CallMain调用的PlayerLoadFirstScene函数，如果PlayerLoadFirstScene耗时占比过高，大多是因为在首场景执行了不必要的操作，比如大量反序列化操作、配置解析操作，按需剔除后再次Profile即可验证效果。</p>',9);function f(u,P,_,C,F,b){const a=e("font");return p(),n("div",null,[E,l("p",null,[i("目前为止，开发者可以操作的主要是PlayerLoadFirstScene函数的调用，参照Unity的Benchmark项目，要尽可能将PlayerLoadFirstScene的耗时控制在整个CallMain耗时的"),r(a,{color:"#dd0000"},{default:o(()=>[i("20%")]),_:1}),i("左右，如果CallMain耗时过大，可以借助上面提到的Profile工具进行优化，下面简单分析流程。")]),y])}const B=t(m,[["render",f]]);export{v as __pageData,B as default};
