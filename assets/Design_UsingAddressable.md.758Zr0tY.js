import{_ as a,c as i,a as e,a4 as s,o as n}from"./chunks/framework.Br2U662V.js";const t="/minigame-unity-webgl-transform/assets/addressable7.D5VA3cAj.png",l="/minigame-unity-webgl-transform/assets/wxassetbundleprovider1.BrJzXZd7.png",p="/minigame-unity-webgl-transform/assets/wxassetbundleprovider2.DIWHTi9X.png",h="/minigame-unity-webgl-transform/assets/addressable2.Dk3Ey3UQ.png",r="/minigame-unity-webgl-transform/assets/addressable5.CfIJPhUo.png",d="/minigame-unity-webgl-transform/assets/addressable10.CVteO2U4.png",k="/minigame-unity-webgl-transform/assets/addressable9.BGoeNYVl.png",o="/minigame-unity-webgl-transform/assets/addressable3.D_qvXfAd.png",C=JSON.parse('{"title":"使用Addressable Assets System进行资源按需加载","description":"","frontmatter":{},"headers":[],"relativePath":"Design/UsingAddressable.md","filePath":"Design/UsingAddressable.md"}'),c={name:"Design/UsingAddressable.md"},g=s('<h1 id="使用addressable-assets-system进行资源按需加载" tabindex="-1">使用Addressable Assets System进行资源按需加载 <a class="header-anchor" href="#使用addressable-assets-system进行资源按需加载" aria-label="Permalink to &quot;使用Addressable Assets System进行资源按需加载&quot;">​</a></h1><h2 id="一、概述" tabindex="-1">一、概述 <a class="header-anchor" href="#一、概述" aria-label="Permalink to &quot;一、概述&quot;">​</a></h2><p>对于Unity WebGL转换的小游戏启动耗时，资源下载通常是贡献最大的部分。这是由于手游APP往往很少针对首包资源进行特殊优化。 那么，接下来的问题是：小游戏中多大的首包资源合适？ 剩余的游戏资源如何加载？ 在此，我们建议得优化原则是：</p><blockquote><ol><li>首包资源量不超过5M</li><li>资源按需延迟加载，拆分得尽量细</li></ol></blockquote><p>本文介绍如何使用Unity新的资源管理流程<a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.1/manual/index.html" target="_blank" rel="noreferrer">Addressable Assets System</a>进行资源的按需加载。</p><p>附可参考的项目： <a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/tree/main/Demo/Addressable" target="_blank" rel="noreferrer">https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/tree/main/Demo/Addressable</a></p><h2 id="二、addressable在小游戏中的应用" tabindex="-1">二、Addressable在小游戏中的应用 <a class="header-anchor" href="#二、addressable在小游戏中的应用" aria-label="Permalink to &quot;二、Addressable在小游戏中的应用&quot;">​</a></h2><h3 id="_2-1-什么是addressable-assets-system" tabindex="-1">2.1 什么是Addressable Assets System <a class="header-anchor" href="#_2-1-什么是addressable-assets-system" aria-label="Permalink to &quot;2.1 什么是Addressable Assets System&quot;">​</a></h3><p>Unity在2018版本中推出了Addressable Assets System（以下简称Addressable）的预览版本，并在2019的版本中已经成为正式版本，可以用于生产（仅表示发布时间，实际上大部分Unity版本都可正常使用）。 Addressable提供了以下能力：</p><blockquote><p>低使用门槛：使用Addressable在开发前期就进入快速开发的阶段，使用任何你喜欢的资源管理技术，你都能快速的切换来Addressable系统中，几乎不需要修改代码。</p></blockquote><blockquote><p>依赖管理：Addressable系统不仅仅会帮你管理、加载你指定的内容，同时它会自动管理并加载好该内容的全部依赖。在所有的依赖加载完成，你的内容彻底可用时，它才会告诉你加载完成。</p></blockquote><blockquote><p>内存管理：Addressable不仅仅能记载资源，同时也能卸载资源。系统自动启用引用计数，并且有一个完善的Profiler帮助你指出潜在的内存问题。</p></blockquote><blockquote><p>内容打包：Addressable系统自动管理了所有复杂的依赖连接，所以即使资源移动了或是重新命名了，系统依然能够高效地找到准确的依赖进行打包。当你需要将打包的资源从本地移到服务器上面，Addressable系统也能轻松做到，几乎不需要任何代价。</p></blockquote><h3 id="_2-2-相对于assetsbundles的优势" tabindex="-1">2.2 相对于AssetsBundles的优势 <a class="header-anchor" href="#_2-2-相对于assetsbundles的优势" aria-label="Permalink to &quot;2.2 相对于AssetsBundles的优势&quot;">​</a></h3><p>Unity中资源按需加载也可以使用老的AssetBundle，然而使用AB需要做不少的工作：标识Asset、组织Bundle、编译、Load/Unload、依赖关系以及后期维护的复杂工作。新一代的Addressable正是对这些痛点做了不少改进，开发者只需要将Asset设置为addressable然后加载即可，[功能强大并且学习曲线变得平滑] (<a href="https://docs.google.com/document/d/1hPLNLdrF0qAvjEJTpKf-cuO_d4FCV0H2cqBeP1Zo6mA/edit" target="_blank" rel="noreferrer">https://docs.google.com/document/d/1hPLNLdrF0qAvjEJTpKf-cuO_d4FCV0H2cqBeP1Zo6mA/edit</a>)。</p><img src="'+t+'" width="600"><h3 id="_2-3-在小游戏中使用addressable-assets-system" tabindex="-1">2.3 在小游戏中使用Addressable Assets System <a class="header-anchor" href="#_2-3-在小游戏中使用addressable-assets-system" aria-label="Permalink to &quot;2.3 在小游戏中使用Addressable Assets System&quot;">​</a></h3><p>无论是Addressable还是AssetBundle在微信小游戏底层都使用XHR进行远程资源访问，并使用微信小游戏文件存储系统进行缓存。对于已有的游戏资源，如果我们需要尽量少的工作量去做到像H5游戏按需加载，使用Addressable是最佳做法。</p><h3 id="_2-4-使用wxassetbundleprovider节省内存" tabindex="-1">2.4 使用WXAssetBundleProvider节省内存 <a class="header-anchor" href="#_2-4-使用wxassetbundleprovider节省内存" aria-label="Permalink to &quot;2.4 使用WXAssetBundleProvider节省内存&quot;">​</a></h3><p><a href="./UsingAssetBundle.html#三、更节省内存的wxassetbundle">WXAssetBundle</a>可以减轻iOS的内存压力，对于使用Addressable的项目，需要替换Provider来使用WXAssetBundle。</p><ol><li><p>下载<a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/tools/WXAssetBundleProvider.cs" target="_blank" rel="noreferrer">WXAssetBundleProvider.cs</a>，放到WX-WASM-SDK-V2/Runtime/目录下</p></li><li><p>导入插件后会有WXAssetBundleProvider.cs缺依赖的报错，需要给WX-WASM-SDK-V2/Runtime 增加 Unity.ResourceManager 的引用 <img src="'+l+'" width="600"></p></li><li><p>进入AA的组设置修改Provider如下 <img src="'+p+'" width="600"></p></li><li><p>重新导出 AA包 和 小游戏</p></li></ol><h2 id="三、启动优化与资源优化实战" tabindex="-1">三、启动优化与资源优化实战 <a class="header-anchor" href="#三、启动优化与资源优化实战" aria-label="Permalink to &quot;三、启动优化与资源优化实战&quot;">​</a></h2><h3 id="_3-1-从首包开始" tabindex="-1">3.1 从首包开始 <a class="header-anchor" href="#_3-1-从首包开始" aria-label="Permalink to &quot;3.1 从首包开始&quot;">​</a></h3><p>首包资源应该只包含首屏所需资源，比如Splash界面以及对应文案。 <img src="'+h+'" width="800"> 首屏资源需要注意：</p><blockquote><ol><li>导出场景不要勾选任何其他场景</li><li>不要打包字体文件，字体往往压缩率很低。</li><li>通过Addressable检查Bultin分组，特别注意不要随意放置资源到Resources目录，该目录将无条件被打包到首包中。</li></ol></blockquote><p>通常，Unity首资源包的压缩率是比较高的，因为大多数Unity built资源是以文本形式存在。开发者应尽量减少首资源包压缩后大小，以zip压缩后体积为准，3M左右最佳，不应超过5M。</p><p>部署首资源包需要注意：</p><blockquote><ol><li>使用“小游戏分包”时，小游戏底层会自动进行压缩减少网络传输。</li><li>使用“CDN”时，务必在服务器对txt后缀开启“Brotli或gzip”。</li></ol></blockquote><h3 id="_3-2-资源按需加载" tabindex="-1">3.2 资源按需加载 <a class="header-anchor" href="#_3-2-资源按需加载" aria-label="Permalink to &quot;3.2 资源按需加载&quot;">​</a></h3><h4 id="_3-2-1-场景动态加载" tabindex="-1">3.2.1 场景动态加载 <a class="header-anchor" href="#_3-2-1-场景动态加载" aria-label="Permalink to &quot;3.2.1 场景动态加载&quot;">​</a></h4><p>如前所述，我们构建时仅选择了splash/loading场景，那么主场景（如大厅/战斗等）该如何加载？此时我们可以<strong>将每个场景单独作为Addressable分组</strong>，在用到的时候才下载该场景包。 <img src="'+r+`" width="800"></p><p>使用Addressables.LoadSceneAsync可以动态加载场景与获取加载进度：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>    IEnumerator LoadMain()</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        var handle = Addressables.LoadSceneAsync(&quot;Assets/RPGPP_LT/Scene/rpgpp_lt_scene_1.0.unity&quot;, LoadSceneMode.Single, true);</span></span>
<span class="line"><span>        handle.Completed  += (obj) =&gt;</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            Debug.LogWarning($&quot;Load async scene complete{obj.Status}&quot;);</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while (!handle.IsDone)</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            // 在此可使用handle.PercentComplete进行进度展示</span></span>
<span class="line"><span>            yield return null;</span></span>
<span class="line"><span>         }</span></span>
<span class="line"><span>    }</span></span></code></pre></div><p>选择分组，设置分组属性如下：</p><img src="`+d+'" width="800"><p>如果我们仅将场景作为分组，其中静态摆放的物件不单独设置为Addressable也会一并打包到场景所在bundle。那么，这是会产生一个问题：两个场景都使用同样资源是否产生冗余？答案是肯定的！！ 那么，如何消除冗余呢？当我们Adressable面板的Tools--&gt;Analyze进行分析时，可看到以下内容：</p><img src="'+k+'" width="800">',37),E=s('<h3 id="_3-2-2-物件动态加载" tabindex="-1">3.2.2 物件动态加载 <a class="header-anchor" href="#_3-2-2-物件动态加载" aria-label="Permalink to &quot;3.2.2 物件动态加载&quot;">​</a></h3><p>除了静态场景外，我们还会经常动态实例化(Instantiate)或在内存中创建资源对象。比如：</p><img src="'+o+`" width="600"><div class="language-C# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LoadAssetScript</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MonoBehaviour</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GameObject</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> somePrefab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Instantiate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(somePrefab);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然而，这样做有个非常严重的问题：Prefab本身以及依赖的所有资源需要在场景加载前完成。在小游戏环境，<strong>这意味着即使还没调用Instantiate，这部分资源就必须准备好，这会极大影响场景初始化速度</strong>。</p><p>那么，如果我们希望把somePrefab以及它的依赖资源打包在Addressable分组进行按需下载应该如何做呢？答案是AssetReference。上述代码改写成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class LoadAssetScript : MonoBehaviour</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    public AssetReference somePrefab;</span></span>
<span class="line"><span>    private void Start()</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        somePrefab.InstantiateAsync().Completed += (obj) =&gt;</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>           // 加载完成回调</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>或协程写法：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class LoadAssetScript : MonoBehaviour</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    public AssetReference somePrefab;</span></span>
<span class="line"><span>    private IEnumerator spawnSomathing()</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        var hanle = somePrefab.InstantiateAsync();</span></span>
<span class="line"><span>        while(!handle.IsDone) {yield return null;}</span></span>
<span class="line"><span>         // 加载完成回调</span></span>
<span class="line"><span>        var gameObject = hanle.Result;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>同时，对应的Prefab在editor中需设置为Addressable，并重新为somePrefab赋值。</p><h3 id="_3-3-小结" tabindex="-1">3.3 小结 <a class="header-anchor" href="#_3-3-小结" aria-label="Permalink to &quot;3.3 小结&quot;">​</a></h3><p>Unity WebGL转换的小游戏普遍存在首包资源较大的情况，而新Address提供了非常好的资源管理流程。我们建议开发者：</p><blockquote><ol><li>精简首场景，首包资源中确保只包含轻量的首屏以及依赖资源</li><li>延迟加载，避免业务逻辑需要全量资源的情况，设计上尽量按需加载</li><li>资源拆分，利用Addressable进行更灵活和细粒度的拆解</li><li>预加载，根据优先级设置需要预加载的分包，利用网络空闲期</li></ol></blockquote><h2 id="四、如何优雅地异步加载" tabindex="-1">四、如何优雅地异步加载 <a class="header-anchor" href="#四、如何优雅地异步加载" aria-label="Permalink to &quot;四、如何优雅地异步加载&quot;">​</a></h2><h3 id="_4-1-最基本的异步回调" tabindex="-1">4.1 最基本的异步回调 <a class="header-anchor" href="#_4-1-最基本的异步回调" aria-label="Permalink to &quot;4.1 最基本的异步回调&quot;">​</a></h3><div class="language-C# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TextureHandle_Completed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AsyncOperationHandle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (handle.Status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AsyncOperationStatus.Succeeded) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Texture2D</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handle.Result;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // The texture is ready for use.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    AsyncOperationHandle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">textureHandle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Addressables.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LoadAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mytexture&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    textureHandle.Completed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TextureHandle_Completed;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_4-2-使用协程" tabindex="-1">4.2 使用协程 <a class="header-anchor" href="#_4-2-使用协程" aria-label="Permalink to &quot;4.2 使用协程&quot;">​</a></h3><div class="language-C# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IEnumerator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    AsyncOperationHandle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Addressables.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LoadAssetAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mytexture&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //if the handle is done, the yield return will still wait a frame, but we can skip that with an IsDone check</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">handle.IsDone)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        yield</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handle;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (handle.Status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AsyncOperationStatus.Succeeded) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Texture2D</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> texture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handle.Result;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // The texture is ready for use.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Release the asset after its use:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Addressables.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(handle);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_4-3-使用await" tabindex="-1">4.3 使用await <a class="header-anchor" href="#_4-3-使用await" aria-label="Permalink to &quot;4.3 使用await&quot;">​</a></h3><div class="language-C# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    AsyncOperationHandle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Addressables.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LoadAssetAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mytexture&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handle.Task;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The task is complete. Be sure to check the Status is successful before storing the Result.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="五、旧系统资源改造" tabindex="-1">五、旧系统资源改造 <a class="header-anchor" href="#五、旧系统资源改造" aria-label="Permalink to &quot;五、旧系统资源改造&quot;">​</a></h2><p>资源系统迁移可参考Unity官方文档<a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.18/manual/AddressableAssetsMigrationGuide.html#the-assetbundles-method" target="_blank" rel="noreferrer">Upgrading to the Addressables system</a></p><h2 id="_5-1-resource改造" tabindex="-1">5.1 Resource改造 <a class="header-anchor" href="#_5-1-resource改造" aria-label="Permalink to &quot;5.1 Resource改造&quot;">​</a></h2><p>使用这种方式加载资源，通常需要再Asset或其子目录下创建Resources的文件夹，然后使用类似这种方式加载：</p><div class="language-C# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       TextAsset</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> text</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Resources.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TextAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;MyConfig&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>然而，Resources目录的内容都会被打包进首包资源，对于小游戏来说是<strong>不推荐使用的方式</strong>。 开发者在Addressable的default中能看到所有这些资源，我们需要将这些资源设置为“Addressable”，Unity将自动移动到“Resources_Moved”目录。 加载代码改写成：</p><div class="language-C# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Addressables.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LoadAssetAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TextAsset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;MyConfig&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">handle.IsDone) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">yield</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handle;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 加载完成回调</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (handle.Status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AsyncOperationStatus.Succeeded) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gameObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hanle.Result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span></code></pre></div><h2 id="_5-2-assetsbundle迁移" tabindex="-1">5.2 AssetsBundle迁移 <a class="header-anchor" href="#_5-2-assetsbundle迁移" aria-label="Permalink to &quot;5.2 AssetsBundle迁移&quot;">​</a></h2><p>当打开Addressables Groups时，Unity提供了将所有AssetsBundle迁移到Addressable Asset Groups的功能。</p><h2 id="六、部署" tabindex="-1">六、部署 <a class="header-anchor" href="#六、部署" aria-label="Permalink to &quot;六、部署&quot;">​</a></h2><h3 id="_6-1-addressable编译与部署" tabindex="-1">6.1 Addressable编译与部署 <a class="header-anchor" href="#_6-1-addressable编译与部署" aria-label="Permalink to &quot;6.1  Addressable编译与部署&quot;">​</a></h3><p>默认情况下，当编译Addressable资源时会输出到Library/com.unity.addressables/，项目发布为WebGL或转换为小游戏时Unity会自动拷贝Bundle文件到最终的生成目录下。我们只需要将对应的StreammingAssets上传到对应的CDN服务器即可。</p><h3 id="_6-2-资源预下载" tabindex="-1">6.2 资源预下载 <a class="header-anchor" href="#_6-2-资源预下载" aria-label="Permalink to &quot;6.2 资源预下载&quot;">​</a></h3><p>为了充分利用网络带宽，在网络空闲时可预下载游戏需要用到的AB包。详细配置请参考<a href="./UsingPreload.html">使用预下载功能</a>。</p><h3 id="五、参考资料" tabindex="-1">五、参考资料 <a class="header-anchor" href="#五、参考资料" aria-label="Permalink to &quot;五、参考资料&quot;">​</a></h3><ol><li><p>Addressable Asset System for Unity (Overview) <a href="https://docs.google.com/document/d/1hPLNLdrF0qAvjEJTpKf-cuO_d4FCV0H2cqBeP1Zo6mA/edit" target="_blank" rel="noreferrer">https://docs.google.com/document/d/1hPLNLdrF0qAvjEJTpKf-cuO_d4FCV0H2cqBeP1Zo6mA/edit</a></p></li><li><p>官方Demo <a href="https://github.com/Unity-Technologies/Addressables-Sample" target="_blank" rel="noreferrer">https://github.com/Unity-Technologies/Addressables-Sample</a></p></li><li><p>视频范例 <a href="https://drive.google.com/file/d/1w-Lh_jsD2VSHNvkzexJLSc6bA3gUQC8d/view" target="_blank" rel="noreferrer">https://drive.google.com/file/d/1w-Lh_jsD2VSHNvkzexJLSc6bA3gUQC8d/view</a></p></li><li><p>uwa关于Addressable的介绍 <a href="https://blog.uwa4d.com/archives/USparkle_Addressable4.html" target="_blank" rel="noreferrer">https://blog.uwa4d.com/archives/USparkle_Addressable4.html</a></p></li><li><p>Addressable与AssetBundle的对比 <a href="https://www.jianshu.com/p/8009c16fcab3" target="_blank" rel="noreferrer">https://www.jianshu.com/p/8009c16fcab3</a></p></li></ol>`,36);function u(b,y,A,m,F,_){return n(),i("div",null,[g,e(" 此时，我们应将这些冗余的内容单独进行设置为Addressable。而更为简单的做法是：选中“Check Duplicate Bundle Dependencies”，点击“Fixed Selected Rules”，工具会自动将冗余项逐个设置为Addressable。 "),E])}const v=a(c,[["render",u]]);export{C as __pageData,v as default};
